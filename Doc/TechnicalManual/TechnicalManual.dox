/**

\page TechnicalManual The Technical Manual

\li \ref TechnicalManualIntro
\li \ref TechnicalManualPreRequisites
\li \ref TechnicalManualBuildProcess
\li \ref TechnicalManualCodeStructure
\li \ref TechnicalManualMessageTypes
\li \ref TechnicalManualSocket
\li \ref TechnicalManualTimeSynch
\li \ref TechnicalManualUseCases

\section TechnicalManualIntro Introduction

NiftyLink is a small messaging library that uses the OpenIGTLink protocol. This manual provides
a brief overview of the build process, code structure and usage patterns.

\section TechnicalManualPreRequisites Prerequisites

First download and install <a href="http://qt.nokia.com/products/">Qt</a>, and
<a href="http://git-scm.com/">Git</a>. The NiftyLink build process will also download a modified version of
<a href="http://www.na-mic.org/Wiki/index.php/OpenIGTLink">OpenIGTLink</a> from
<a href="https://github.com/">GitHub</a>, so an internet connection is required.

\section TechnicalManualBuildProcess Build Process

\image html NiftyLinkCMake.png "Figure 1. Using CMake, specify the source directory, and a different build directory."

NiftyLink is built using <a href="http://www.cmake.org">CMake</a>. To build NiftyLink perform the following:

\li Launch the CMake GUI.
\li Specify a source folder and a different build folder. See Figure 1.
\li Press Configure
\li Specify the CMAKE_BUILD_TYPE as either Debug or Release.
\li Specify BUILD_TESTING as either on/checked or off/checked depending on if you want unit tests.
\li You do not need to specify the CMAKE_INSTALL_PREFIX as there is no install task.
\li Press Configure
\li Press Generate
\li Exit the CMake GUI.

NiftyLink uses a "Meta-Build", sometimes called a "Super-Build", meaning that the build process
will download and build dependent libraries. The top-level build folder contains a sub-folder called
NiftyLink-build.  The top-level folder will be used to build dependencies (OpenIGTLink), and when
this is done, NiftyLink is built within the sub-folder NiftyLink-build. This means that the first
build, is run from the top-level. Once this is done, the repeated code-compile-test cycle is
performed within the sub-folder.

To start the build
\li On Windows, launch the NIFTYLINK-SUPERBUILD.sln solution file and use the BUILD task
\li On Linux and Mac, use the make command

Linux and Mac users are likely to be more familiar with the ccmake version of CMake. The following
commands are analagous to those steps performed using the GUI. Download the NiftyLink code into
the current folder, then:

\verbatim
mkdir NiftyLink-build
cd NiftyLink-build
ccmake ../NiftyLink
--- Then within ccmake, configure variables as above --
make
\endverbatim

\section TechnicalManualCodeStructure Code Structure

The code structure is currently a single library:
\verbatim
NiftyLink/Code/Libraries/Common
NiftyLink/Code/Libraries/TimeSync
NiftyLink/Code/Libraries/*.h
NiftyLink/Code/Libraries/*.cpp
NiftyLink/Code/Libraries/CMakeLists.txt
\endverbatim

The CMakeLists.txt can be used to identify how the library is put together. The final output is
a single library called libniftylink.so on Linux, libniftylink.dylib on Mac, and niftylink.dll on Windows.
In addition, the unit tests are stored under a separate folder called Testing.
The Testing folder mirrors the Code directory structure:

NiftyLink/Testing/Code/Libraries/

and again CMakeLists.txt can be inspected to see how the tests are put together. Future development
should ensure that these two directory structures match each other.

\section TechnicalManualMessageTypes Message Types

\image html NiftyLinkMessageTypes.png "Figure 2. Each message type derives from the base class OIGTLMessage"

The main folder
\verbatim
NiftyLink/Code/Libraries/
\endverbatim
contains several classes that describe basic message types, as seen in Figure 2.
Currently OIGTLImageMessage, OIGTLStatusMessage, OIGTLStringMessage, OIGTLTrackingDataMessage
and OIGTLTransformMessage are derived from OIGTLMessage. Further types may be added in the future.

Each message type is derived from the Qt QSharedData to provide a solid basis for sharing objects and
reference counting. The base class provides common reference data such as created time, received time,
sender host name, sender port, message ID and so on. The derived classes provide the specific
data for each message type.

\section TechnicalManualSocket Socket Object

NiftyLink provides a class OIGTLSocketObject that encapsulates the concept of sending and receiving messages.
For example an OIGTLSocketObject provides methods to:

\li OIGTLSocketObject::listenOnPort() listen on a port
\li OIGTLSocketObject::connectToRemote() connect to a remote port
\li OIGTLSocketObject::closeSocket() close the sender and listener.

Important events are signalled using Qt signals and slots. For example:

\li OIGTLSocketObject::messageReceived() a message has been received, and needs processing.
\li OIGTLSocketObject::lostConnectionToRemoteSignal() lost connection to the remote sender.

A large part of the significant additional functionality provided by NiftyLink over OpenIGTLink is
in the reliability of communication. This OIGTLSocketObject provides a simple way to use sockets reliably.

\section TechnicalManualProcess Process Objects

The OIGTLSocketObject contains two threads, running an OIGTLSenderProcess and an OIGTLListenerProcess, both of which
are derived from OIGTLProcessBase. Conceptually, the OIGTLProcessBase provides methods to specify things like
connection time-outs and keep track of whether a process is currently running and active. Again, as with OIGTLSocketObject
important events are signalled using Qt signals and slots. For the end-user of NiftyLink, it is envisaged that the main
usage pattern is to use a OIGTLSocketObject to send various messages, and the contained objects within OIGTLSocketObject
should just work. For the developer of NiftyLink, it is important that unit-tests exercise as many test cases as possible
to ensure reliable connections.

\section TechnicalManualTimeSynch Time Synchronisation

The time synchronisation framework in folder
\verbatim
NiftyLink/Code/Libraries/TimeSynch
\endverbatim
will provide the ability to sample data on multiple machines, and correctly time-stamp the data.
This is work in progress, and not yet finished.

\section TechnicalManualUseCases Typical Use Cases

Using NiftyLink is easy due to the Qt based OIGTLSocketObject and the various message types derived from OIGTLMessage.
The following code was based on the Surgical Guidance Plugin of NiftyView.

\li A socket is created:
\code
OIGTLSocketObject *socket = NULL;
socket = new OIGTLSocketObject();
\endcode
\li Connect the sockets signals to a containing class, here, we are simply using the <code>this</code> pointer.
\code
connect(socket, SIGNAL(clientConnectedSignal()), this, SLOT(clientConnected()) );
connect(socket, SIGNAL(clientDisconnectedSignal()), this, SLOT(clientDisconnected()) );
connect(socket, SIGNAL(messageReceived(OIGTLMessage::Pointer )), this, SLOT(interpretMessage(OIGTLMessage::Pointer )), Qt::QueuedConnection);
\endcode
\li Then tell the socket to listen
\code
socket->listenOnPort(int portNumber)
\endcode
and incomming messages will be passed into the specified slot, here called interpretMessage.
\li Or we can send data using
\code
socket->sendMessage(OIGTLMessage::Pointer message);
\endcode

The developer should additionally directly read the Unit Tests, as these provide an exact specification.
Another way to understand the usage is to see the code in action, in either the NiftyView or NiftyGuide projects.

*/
